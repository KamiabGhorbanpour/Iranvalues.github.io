<!DOCTYPE html>
<html>
<head>
  <link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:400,700" rel="stylesheet">
  <link href="style.css" rel="stylesheet" type="text/css">
  <title>Iranvalues Results</title>
  <link rel="icon" type="x-icon" href="icon.png">
  <link rel="shortcut icon" type="x-icon" href="icon.png">
  <meta charset="utf-8">
</head>

<body>
  <h1>Iranvalues</h1>
  <hr>
  <h2 style="text-align:center;">Your Results</h2>

  <!-- DOCTRINAL / MULTI-LAYER RESULT -->
  <div class="explanation_bg" style="margin-top: 20px;">
    <div class="spacer">
      <h2 style="text-align:center;">Doctrinal Result</h2>
      <p id="branch-title" style="text-align:center; font-size: 15pt; margin-bottom: 6px;"></p>
      <p id="branch-desc" style="text-align:center; opacity: 0.9; margin-top: 0;"></p>

      <p style="text-align:center; opacity: 0.8; font-size: 11.5pt; margin-top: 10px; line-height: 1.4;">
        Method note: This result uses <b>multi-layer branching</b> (gated question sets).
        You qualify for Marx first, then a tilt layer, then Lenin, then MLM. The label shown reflects the <b>deepest layer reached</b>.
      </p>
    </div>
  </div>

  <!-- VERY VISIBLE DEBUG (REMOVE LATER) -->
  <div class="explanation_bg" style="margin-top: 20px;">
    <div class="spacer">
      <h2 style="text-align:center;">Debug (remove later)</h2>
      <pre id="debug-out" style="white-space: pre-wrap; font-size: 11pt;"></pre>
    </div>
  </div>

  <!-- AXIS RESULTS -->
  <div id="axes-results"></div>

  <p style="text-align:center; margin-top: 24px;">
    <a href="index.html">Take the quiz again</a>
  </p>

  <!-- Load axes definition -->
  <script src="axes.js"></script>

  <script>
    /* ============================
       READ STORED DATA
       ============================ */

    let scores = {};
    let flags = {};

    try { scores = JSON.parse(localStorage.getItem("scores") || "{}"); } catch (e) { scores = {}; }
    try { flags  = JSON.parse(localStorage.getItem("flags")  || "{}"); } catch (e) { flags  = {}; }

    const scoreKeys = (scores && typeof scores === "object") ? Object.keys(scores) : [];

    /* ============================
       HELPERS
       ============================ */

    function num(x) {
      const n = parseFloat(x);
      return Number.isFinite(n) ? n : 0;
    }

    // Try to fetch a score by key, but also try common alternates and fuzzy matches.
    function getScore(key) {
      if (!scores || typeof scores !== "object") return 0;

      // direct
      if (Object.prototype.hasOwnProperty.call(scores, key)) return num(scores[key]);

      // common alternates: hyphen/underscore/case
      const alt1 = key.replace(/-/g, "_");
      const alt2 = key.replace(/_/g, "-");
      const alt3 = key.toLowerCase();
      const alt4 = key.toUpperCase();

      for (const k of [alt1, alt2, alt3, alt4]) {
        if (Object.prototype.hasOwnProperty.call(scores, k)) return num(scores[k]);
      }

      // fuzzy: find any key that contains this key
      // (helps if your quiz stores like "econ_left_total" but axes expects "econ_left")
      const found = scoreKeys.find(sk => ("" + sk).toLowerCase().includes(("" + key).toLowerCase()));
      if (found) return num(scores[found]);

      return 0;
    }

    function rightPercent(leftKey, rightKey) {
      const L = getScore(leftKey);
      const R = getScore(rightKey);

      const denom = Math.abs(L) + Math.abs(R);
      if (denom === 0) return 50;

      const rpct = (Math.abs(R) / denom) * 100;
      const diff = R - L;
      return diff < 0 ? (100 - rpct) : rpct;
    }

    function axisBlock(axis) {
      const r = rightPercent(axis.leftKey, axis.rightKey);
      const l = 100 - r;

      return `
        <div class="axis">
          <div class="axis-title">${axis.title}</div>
          <div class="bar">
            <div class="bar-left" style="width:${l}%"></div>
            <div class="bar-right" style="width:${r}%"></div>
          </div>
          <div class="axis-labels">
            <span>${axis.leftLabel} (${l.toFixed(0)}%)</span>
            <span>${axis.rightLabel} (${r.toFixed(0)}%)</span>
          </div>
        </div>
      `;
    }

    /* ============================
       DOCTRINAL BRANCH LOGIC
       ============================ */

    function determineBranch(f) {
      if (!f || typeof f !== "object") return { title: "Axis-based result only", desc: "No doctrinal branch reached." };

      if (f.mlmQualified) return { title: "Marxism–Leninism–Maoism (MLM)", desc: "Deepest doctrinal layer reached." };
      if (f.leninistEligible) return { title: "Leninist Marxism", desc: "Leninist layer reached, MLM not reached." };
      if (f.authMarx === true) return { title: "Authoritarian-leaning Marxism", desc: "Marx qualified + centralist tilt." };
      if (f.authMarx === false) return { title: "Democratic / pluralist Marxism", desc: "Marx qualified + pluralist tilt." };
      if (f.marxEligible) return { title: "Marxism (general)", desc: "Marx qualified only." };

      return { title: "Axis-based result only", desc: "You did not enter any doctrinal branch." };
    }

    const branch = determineBranch(flags);
    document.getElementById("branch-title").textContent = branch.title;
    document.getElementById("branch-desc").textContent = branch.desc;

    /* ============================
       RENDER AXES
       ============================ */

    const root = document.getElementById("axes-results");
    const axesOk = (typeof AXES !== "undefined" && Array.isArray(AXES) && AXES.length > 0);

    if (!axesOk) {
      root.innerHTML = "<p style='text-align:center;'>AXES not loaded. Check axes.js link.</p>";
    } else {
      root.innerHTML = AXES.map(axisBlock).join("");
    }

    /* ============================
       DEBUG OUTPUT (DIRECT + USEFUL)
       ============================ */

    const dbg = document.getElementById("debug-out");
    let debugText = "";

    debugText += "scores exists: " + (localStorage.getItem('scores') !== null) + "\n";
    debugText += "score key count: " + scoreKeys.length + "\n";
    debugText += "score keys: " + (scoreKeys.length ? scoreKeys.join(", ") : "(none)") + "\n\n";

    debugText += "AXES loaded: " + axesOk + "\n";
    if (axesOk) {
      debugText += "AXES count: " + AXES.length + "\n\n";
      // print first 3 axes key lookups
      const n = Math.min(3, AXES.length);
      for (let i = 0; i < n; i++) {
        const a = AXES[i];
        const Lraw = scores[a.leftKey];
        const Rraw = scores[a.rightKey];
        const L = getScore(a.leftKey);
        const R = getScore(a.rightKey);
        debugText += `Axis[${i}] ${a.title}\n`;
        debugText += `  leftKey:  ${a.leftKey}  raw:${Lraw}  parsed:${L}\n`;
        debugText += `  rightKey: ${a.rightKey} raw:${Rraw}  parsed:${R}\n`;
        debugText += `  denom: ${Math.abs(L)+Math.abs(R)}\n\n`;
      }
    }

    dbg.textContent = debugText;
  </script>

  <style>
    .axis { margin: 18px 0; }
    .axis-title { font-weight: 700; margin-bottom: 8px; }
    .bar { display:flex; height:18px; border-radius:10px; overflow:hidden; background:#eee; }
    .bar-left { background:#444; }
    .bar-right { background:#999; }
    .axis-labels { display:flex; justify-content:space-between; margin-top:6px; font-size:14px; }
  </style>
</body>
</html>
