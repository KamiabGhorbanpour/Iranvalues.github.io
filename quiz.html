<!DOCTYPE html>
<html>
<head>
  <link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:400,700" rel="stylesheet">
  <link href="style.css" rel="stylesheet" type="text/css">
  <title>Iranvalues Quiz</title>
  <link rel="icon" type="x-icon" href="icon.png">
  <link rel="shortcut icon" type="x-icon" href="icon.png">
  <meta charset="utf-8">

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-6511426299019766",
      enable_page_level_ads: true
    });
  </script>
</head>

<body>

<h1>Iranvalues</h1>
<hr>
<h2 style="text-align:center;" id="question-number">Loading…</h2>
<p class="question" id="question-text"></p>

<button class="button stronglyAgree" onclick="next_question( 1.0)">Strongly Agree</button> <br>
<button class="button agree" onclick="next_question( 0.5)">Agree</button> <br>
<button class="button neutral" onclick="next_question( 0.0)">Neutral/Unsure</button> <br>
<button class="button disagree" onclick="next_question(-0.5)">Disagree</button> <br>
<button class="button stronglyDisagree" onclick="next_question(-1.0)">Strongly Disagree</button> <br>

<button class="small_button" onclick="prev_question()" id="back_button">Back</button>
<button class="small_button_off" id="back_button_off">Back</button><br>

<!-- Axes + Questions -->
<script src="axes.js"></script>
<script src="questions.js?v=mlsplit3"></script>

<!-- Website visit statistics - no personal information is collected! -->
<script type="text/javascript">
  var sc_project=11325211;
  var sc_invisible=1;
  var sc_security="fd9f0659";
  var scJsHost = (("https:" == document.location.protocol) ? "https://secure." : "http://www.");
  document.write("<sc"+"ript type='text/javascript' src='" + scJsHost + "statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="web stats"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11325211/0/fd9f0659/1/" alt="web
stats"></a></div></noscript>

<script>
  // ---------- FAIL-LOUD ERROR BOX ----------
  function fatal(msg) {
    const qn = document.getElementById("question-number");
    const qt = document.getElementById("question-text");

    if (qn) qn.textContent = "Error";
    if (qt) qt.textContent = "";

    let box = document.getElementById("fatal-box");
    if (!box) {
      box = document.createElement("pre");
      box.id = "fatal-box";
      box.style.whiteSpace = "pre-wrap";
      box.style.maxWidth = "980px";
      box.style.margin = "16px auto";
      box.style.padding = "14px";
      box.style.border = "2px solid #cc4444";
      box.style.borderRadius = "12px";
      box.style.background = "#1b1b1b";
      box.style.color = "#ffffff";
      box.style.fontSize = "14px";
      box.style.lineHeight = "1.45";
      document.body.insertBefore(box, document.body.firstChild);
    }
    box.textContent = msg;
  }

  window.addEventListener("error", function (e) {
    const msg =
      "JavaScript crashed.\n\n" +
      (e.message || "Unknown error") + "\n" +
      (e.filename ? ("File: " + e.filename + "\n") : "") +
      (e.lineno ? ("Line: " + e.lineno + ":" + e.colno + "\n\n") : "") +
      (e.error && e.error.stack ? e.error.stack : "");
    fatal(msg);
  });

  // ---------- HARD GUARDS ----------
  if (typeof questions === "undefined") {
    fatal(
      "questions is not defined.\n\n" +
      "This usually means questions.js failed to load or has a syntax error.\n" +
      "Open DevTools → Console, reload, and you'll see the exact error line in questions.js."
    );
  }

  if (typeof questions !== "undefined" && !Array.isArray(questions)) {
    fatal("questions exists, but it is not an array. Fix questions.js export.");
  }

  // ---------- ENGINE ----------
  const state = {
    scores: (() => {
      try { return JSON.parse(localStorage.getItem("scores") || "{}"); }
      catch (e) { return {}; }
    })(),
    answers: (() => {
      try { return JSON.parse(localStorage.getItem("answers") || "{}"); }
      catch (e) { return {}; }
    })(),
    flags: {
      marxEligible: false,
      authMarx: null,          // true/false/null (null = not answered / neutral)
      leninistEligible: false,
      mlStalinEligible: false,
      mlmQualified: false,

      // NEW (optional but useful for later results logic)
      demSocEligible: false,
      reformMarx: false,
      revolutionMarx: false
    },
    history: [],
    pos: -1
  };

  function num(x) {
    const n = parseFloat(x);
    return Number.isFinite(n) ? n : 0;
  }

  function setScore(key, delta) {
    state.scores[key] = num(state.scores[key]) + delta;
  }

  function applyEffect(q, mult) {
    if (!q || !q.effect) return;
    for (const k of Object.keys(q.effect)) {
      setScore(k, mult * q.effect[k]);
    }
  }

  function isAgree(mult) { return mult >= 0.5; }
  function isDisagree(mult) { return mult <= -0.5; }
  function isUnsure(mult) { return mult === 0.0; }

  function safeShowIf(q) {
    if (!q || !q.showIf) return true;
    try { return !!q.showIf(state); }
    catch (e) {
      console.error("showIf crashed for:", q.id, e);
      return false;
    }
  }

  function recomputeFlags() {
    // --------------------------
    // 1) Marx eligibility: use ONLY marxCore items
    // --------------------------
    const marxCoreQs = questions.filter(q => q && q.meta && q.meta.marxCore);
    const answeredCore = marxCoreQs.filter(q => state.answers[q.id] !== undefined);

    let coreAgree = 0;
    for (const q of marxCoreQs) {
      const m = state.answers[q.id];
      if (m === undefined) continue;
      if (isAgree(m)) coreAgree++;
    }

    // Require completion of core set, then threshold.
    // With current questions: marxCore count should be 6 (mx_01..mx_05, mx_07).
    const coreComplete = answeredCore.length === marxCoreQs.length;
    // Threshold: 4/6 (tune later)
    state.flags.marxEligible = coreComplete ? (coreAgree >= 4) : false;

    // --------------------------
    // 2) Reform vs rupture tilt inside Marx (optional helper flags)
    // --------------------------
    const ruptureQs = questions.filter(q => q && q.meta && q.meta.marxRupture);
    const answeredRupture = ruptureQs.filter(q => state.answers[q.id] !== undefined);

    let ruptureAgree = 0;
    for (const q of ruptureQs) {
      const m = state.answers[q.id];
      if (m === undefined) continue;
      if (isAgree(m)) ruptureAgree++;
    }

    // Only meaningful after Marx eligibility; also require rupture questions answered for stability.
    const ruptureComplete = answeredRupture.length === ruptureQs.length;
    if (state.flags.marxEligible && ruptureComplete) {
      // With current questions: marxRupture count is 3 (mx_06, mx_08, mx_09)
      state.flags.revolutionMarx = (ruptureAgree >= 2);
      state.flags.reformMarx = (ruptureAgree <= 1);
    } else {
      state.flags.revolutionMarx = false;
      state.flags.reformMarx = false;
    }

    // --------------------------
    // 3) Auth tilt: mx_tilt_pluralism (provisional)
    // --------------------------
    const tiltQ = questions.find(q => q && q.meta && q.meta.authTilt);
    if (tiltQ && state.answers[tiltQ.id] !== undefined && state.flags.marxEligible) {
      const m = state.answers[tiltQ.id];
      if (isAgree(m)) state.flags.authMarx = true;
      else if (isDisagree(m)) state.flags.authMarx = false;
      else state.flags.authMarx = null;
    } else {
      state.flags.authMarx = null;
    }

    // --------------------------
    // 4) Circle-backs that can OVERRIDE authMarx
    // --------------------------
    // 4a) From DemSoc/pluralist track -> bounce into authMarx
    const cbAuth = questions.find(q => q && q.meta && q.meta.authCircleBack);
    if (cbAuth && state.answers[cbAuth.id] !== undefined && state.flags.marxEligible) {
      const m = state.answers[cbAuth.id];
      // If they agree-ish that censorship/party restriction is justified, force authMarx.
      if (isAgree(m)) state.flags.authMarx = true;
      // If they strongly disagree, strongly indicates not-auth.
      if (isDisagree(m)) state.flags.authMarx = false;
    }

    // 4b) From auth/Lenin track -> bounce out into DemSoc
    const cbDemSoc = questions.find(q => q && q.meta && q.meta.demSocCircleBack);
    let cbDemSocAgree = false;
    if (cbDemSoc && state.answers[cbDemSoc.id] !== undefined && state.flags.marxEligible) {
      const m = state.answers[cbDemSoc.id];
      if (isAgree(m)) cbDemSocAgree = true;
      if (cbDemSocAgree) state.flags.authMarx = false;
    }

    // --------------------------
    // 5) Leninist eligibility (2/3 on len_01..len_03), but:
    // - only if authMarx === true
    // - and NOT overridden by DemSoc circleback
    // --------------------------
    const requiredLenIds = ["len_01","len_02","len_03"];
    let found = 0, answered = 0, agree = 0;

    for (const id of requiredLenIds) {
      const q = questions.find(x => x && x.id === id);
      if (!q) continue;
      found++;

      if (!safeShowIf(q)) continue;

      const m = state.answers[id];
      if (m === undefined) continue;
      answered++;

      if (isAgree(m)) agree++;
    }

    state.flags.leninistEligible =
      (found === 3 && answered === 3 && state.flags.authMarx === true && !cbDemSocAgree)
        ? (agree >= 2)
        : false;

    // --------------------------
    // 6) ML(Stalinism) split: meta.mlStalinSplit
    // --------------------------
    const splitQ = questions.find(q => q && q.meta && q.meta.mlStalinSplit);
    if (state.flags.leninistEligible && splitQ && state.answers[splitQ.id] !== undefined) {
      state.flags.mlStalinEligible = isDisagree(state.answers[splitQ.id]);
    } else {
      state.flags.mlStalinEligible = false;
    }

    // --------------------------
    // 7) DemSoc eligibility (simple rule)
    // Only meaningful when Marx-eligible and NOT authMarx
    // --------------------------
    state.flags.demSocEligible = false;
    if (state.flags.marxEligible && state.flags.authMarx !== true) {
      const dsQs = questions.filter(q => q && q.meta && q.meta.demSocGate).filter(q => safeShowIf(q));
      const dsConfirmQ = questions.find(q => q && q.meta && q.meta.demSocConfirm);

      let dsAnswered = 0, dsAgree = 0, dsStrongDisagree = 0;
      for (const q of dsQs) {
        const m = state.answers[q.id];
        if (m === undefined) continue;
        dsAnswered++;
        if (isAgree(m)) dsAgree++;
        if (isDisagree(m)) dsStrongDisagree++;
      }

      const confirmAnswered = dsConfirmQ && state.answers[dsConfirmQ.id] !== undefined;
      const confirmOk = !confirmAnswered || (state.answers[dsConfirmQ.id] >= 0);

      // Enforce only once the whole dsGate set has been answered (so it doesn't flip mid-way).
      if (dsQs.length > 0 && dsAnswered === dsQs.length && confirmOk) {
        // Threshold: 4-of-(dsQs.length) and at most 1 strong-disagree
        state.flags.demSocEligible = (dsAgree >= 4 && dsStrongDisagree <= 1);
      }
    }

    // --------------------------
    // 8) MLM gate: if ML(Stalinism), MLM must be false
    // --------------------------
    if (state.flags.mlStalinEligible) {
      state.flags.mlmQualified = false;
      return;
    }

    const mlmQs = questions
      .filter(q => q && q.meta && q.meta.mlmGate)
      .filter(q => safeShowIf(q));

    let answeredMlm = 0;
    let unsureMlm = 0;
    let anyDisagree = false;

    for (const q of mlmQs) {
      const m = state.answers[q.id];
      if (m === undefined) continue;

      answeredMlm++;
      if (isUnsure(m)) unsureMlm++;
      if (isDisagree(m)) anyDisagree = true;
    }

    if (mlmQs.length > 0 && answeredMlm === mlmQs.length && state.flags.leninistEligible) {
      state.flags.mlmQualified = (!anyDisagree && unsureMlm <= 1);
    } else {
      state.flags.mlmQualified = false;
    }
  }

  function findNextIndex(fromIndex) {
    for (let i = fromIndex + 1; i < questions.length; i++) {
      if (safeShowIf(questions[i])) return i;
    }
    return -1;
  }

  function persist() {
    localStorage.setItem("scores", JSON.stringify(state.scores));
    localStorage.setItem("answers", JSON.stringify(state.answers));
    localStorage.setItem("flags", JSON.stringify(state.flags));
    localStorage.setItem("path", JSON.stringify(state.history.map(i => questions[i].id)));
  }

  function currentIndex() {
    if (state.pos >= 0 && state.pos < state.history.length) return state.history[state.pos];
    return -1;
  }

  function init_question() {
    const idx = currentIndex();
    if (idx === -1) return;

    const q = questions[idx];
    const qt = document.getElementById("question-text");
    const qn = document.getElementById("question-number");

    if (!qt || !qn) {
      fatal("Missing #question-text or #question-number in quiz.html");
      return;
    }

    qt.innerHTML = q.question;
    qn.innerHTML = "Question " + (state.pos + 1) + " of " + state.history.length;

    if (state.pos === 0) {
      document.getElementById("back_button").style.display = "none";
      document.getElementById("back_button_off").style.display = "block";
    } else {
      document.getElementById("back_button").style.display = "block";
      document.getElementById("back_button_off").style.display = "none";
    }
  }

  function start() {
    if (typeof questions === "undefined" || !Array.isArray(questions)) return;

    recomputeFlags();
    const first = findNextIndex(-1);

    if (first === -1) {
      fatal(
        "No eligible questions found.\n\n" +
        "This means every question is being hidden by showIf.\n" +
        "Likely cause: a showIf condition expects a flag that never becomes true."
      );
      return;
    }

    state.history = [first];
    state.pos = 0;
    init_question();
  }

  // IMPORTANT: These MUST be global because your buttons call them
  function next_question(mult) {
    const idx = currentIndex();
    if (idx === -1) return;

    const q = questions[idx];

    applyEffect(q, mult);
    state.answers[q.id] = mult;

    recomputeFlags();
    persist();

    if (state.pos < state.history.length - 1) {
      state.history = state.history.slice(0, state.pos + 1);
    }

    const nextIdx = findNextIndex(idx);
    if (nextIdx === -1) {
      recomputeFlags();
      persist();
      location.href = "results.html";
      return;
    }

    state.history.push(nextIdx);
    state.pos++;
    init_question();
  }

  function prev_question() {
    if (state.pos <= 0) return;

    // NOTE: We do NOT undo score deltas here (same as your original).
    // Back is only navigation; next answer overwrites state.answers[q.id] but scores remain cumulative.
    // If you later want true backtracking, we can recompute scores from scratch each time.

    state.pos--;
    init_question();
  }

  // Expose to buttons
  window.next_question = next_question;
  window.prev_question = prev_question;

  // Start when everything is ready
  start();
</script>

</body>
</html>
