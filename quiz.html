<script>
  // --- Branching quiz engine ---
  // Expects: questions (from questions.js)
  // Saves: localStorage.scores + localStorage.flags + localStorage.path (+ answers)

  // 0) HARD GUARD: if questions.js didn't load, don't go blank
  if (typeof questions === "undefined" || !Array.isArray(questions)) {
    const qn = document.getElementById("question-number");
    const qt = document.getElementById("question-text");
    if (qn) qn.innerHTML = "Error";
    if (qt) {
      qt.style.whiteSpace = "pre-wrap";
      qt.innerHTML =
        "questions.js did not load, or it has a syntax error.\n\n" +
        "Open DevTools â†’ Console to see the exact error and line number.\n" +
        "Common cause: a missing comma or bracket in questions.js.";
    }
    throw new Error("questions.js not loaded or invalid");
  }

  const state = {
    scores: (() => {
      try { return JSON.parse(localStorage.getItem("scores") || "{}"); }
      catch (e) { return {}; }
    })(),
    answers: (() => {
      try { return JSON.parse(localStorage.getItem("answers") || "{}"); }
      catch (e) { return {}; }
    })(),
    flags: {
      marxEligible: false,
      authMarx: null,
      leninistEligible: false,
      mlStalinEligible: false,
      mlmQualified: false
    },
    history: [],
    pos: -1
  };

  function num(x) {
    const n = parseFloat(x);
    return Number.isFinite(n) ? n : 0;
  }

  function setScore(key, delta) {
    state.scores[key] = num(state.scores[key]) + delta;
  }

  function applyEffect(q, mult) {
    if (!q || !q.effect) return;
    for (const k of Object.keys(q.effect)) {
      setScore(k, mult * q.effect[k]);
    }
  }

  function isAgree(mult) { return mult >= 0.5; }
  function isDisagree(mult) { return mult <= -0.5; }
  function isUnsure(mult) { return mult === 0.0; }

  // 1) SAFETY: never let showIf crash the quiz
  function safeShowIf(q) {
    if (!q || !q.showIf) return true;
    try {
      return !!q.showIf(state);
    } catch (e) {
      console.error("showIf crashed for question:", q && q.id, e);
      // Default to NOT showing a broken conditional question
      return false;
    }
  }

  function recomputeFlags() {
    // --- Marx eligibility ---
    const marxQs = questions.filter(q => q && q.meta && q.meta.marxGate);
    const answeredMarx = marxQs.filter(q => state.answers[q.id] !== undefined);

    let marxAgree = 0;
    for (const q of marxQs) {
      const m = state.answers[q.id];
      if (m === undefined) continue;
      if (isAgree(m)) marxAgree += 1;
    }

    const marxComplete = (answeredMarx.length === marxQs.length);
    state.flags.marxEligible = marxComplete ? (marxAgree >= 6) : false;

    // --- Auth Marx tilt ---
    const tiltQ = questions.find(q => q && q.meta && q.meta.authTilt);
    if (tiltQ && state.answers[tiltQ.id] !== undefined) {
      const m = state.answers[tiltQ.id];
      if (isAgree(m)) state.flags.authMarx = true;
      else if (isDisagree(m)) state.flags.authMarx = false;
      else state.flags.authMarx = null;
    } else {
      state.flags.authMarx = null;
    }

    // --- Leninist eligibility ---
    const requiredLenIds = ["len_01","len_02","len_03"];
    let reqAgree = 0, reqAnswered = 0;

    for (const id of requiredLenIds) {
      const q = questions.find(x => x && x.id === id);
      if (!q) continue;
      if (!safeShowIf(q)) continue;

      const m = state.answers[id];
      if (m === undefined) continue;

      reqAnswered += 1;
      if (isAgree(m)) reqAgree += 1;
    }

    state.flags.leninistEligible =
      (reqAnswered === requiredLenIds.length) ? (reqAgree >= 2) : false;

    // --- ML (Stalinism) vs MLM split (existing question tagged meta.mlStalinSplit) ---
    const splitQ = questions.find(q => q && q.meta && q.meta.mlStalinSplit);
    if (state.flags.leninistEligible && splitQ && state.answers[splitQ.id] !== undefined) {
      state.flags.mlStalinEligible = isDisagree(state.answers[splitQ.id]);
    } else {
      state.flags.mlStalinEligible = false;
    }

    // --- MLM qualification ---
    // If ML(Stalinism) triggered, MLM cannot be true.
    if (state.flags.mlStalinEligible) {
      state.flags.mlmQualified = false;
      return;
    }

    const mlmQs = questions.filter(q => q && q.meta && q.meta.mlmGate);
    const relevantMlmQs = mlmQs.filter(q => safeShowIf(q));

    let mlmUnsure = 0, mlmAnswered = 0;

    for (const q of relevantMlmQs) {
      const m = state.answers[q.id];
      if (m === undefined) continue;
      mlmAnswered += 1;
      if (isUnsure(m)) mlmUnsure += 1;
    }

    if (relevantMlmQs.length > 0 && mlmAnswered === relevantMlmQs.length) {
      let anyDisagree = false;
      for (const q of relevantMlmQs) {
        const m = state.answers[q.id];
        if (m !== undefined && isDisagree(m)) { anyDisagree = true; break; }
      }
      state.flags.mlmQualified = (!anyDisagree && (mlmUnsure <= 1));
    } else {
      state.flags.mlmQualified = false;
    }
  }

  function findNextIndex(fromIndex) {
    for (let i = fromIndex + 1; i < questions.length; i++) {
      if (safeShowIf(questions[i])) return i;
    }
    return -1;
  }

  function persistState() {
    localStorage.setItem("scores", JSON.stringify(state.scores));
    localStorage.setItem("flags", JSON.stringify(state.flags));
    localStorage.setItem("answers", JSON.stringify(state.answers));
    localStorage.setItem("path", JSON.stringify(state.history.map(i => questions[i].id)));
  }

  function currentIndex() {
    if (state.pos >= 0 && state.pos < state.history.length) return state.history[state.pos];
    return -1;
  }

  function init_question() {
    const idx = currentIndex();
    if (idx === -1) return;

    const q = questions[idx];
    document.getElementById("question-text").innerHTML = q.question;
    document.getElementById("question-number").innerHTML =
      "Question " + (state.pos + 1) + " of " + state.history.length;

    if (state.pos === 0) {
      document.getElementById("back_button").style.display = "none";
      document.getElementById("back_button_off").style.display = "block";
    } else {
      document.getElementById("back_button").style.display = "block";
      document.getElementById("back_button_off").style.display = "none";
    }
  }

  function start() {
    // Ensure flags reflect any restored answers (prevents broken showIf early)
    recomputeFlags();

    const first = findNextIndex(-1);
    if (first === -1) return results();

    state.history = [first];
    state.pos = 0;
    init_question();
  }

  function next_question(mult) {
    const idx = currentIndex();
    if (idx === -1) return;

    const q = questions[idx];

    applyEffect(q, mult);
    state.answers[q.id] = mult;

    recomputeFlags();
    persistState();

    if (state.pos < state.history.length - 1) {
      state.history = state.history.slice(0, state.pos + 1);
    }

    const nextIdx = findNextIndex(idx);
    if (nextIdx === -1) return results();

    state.history.push(nextIdx);
    state.pos += 1;
    init_question();
  }

  function prev_question() {
    if (state.pos <= 0) return;
    state.pos -= 1;
    init_question();
  }

  function results() {
    recomputeFlags();
    persistState();
    location.href = "results.html";
  }

  start();
</script>
