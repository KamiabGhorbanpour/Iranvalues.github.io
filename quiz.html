<script>
  // --- Branching quiz engine ---
  // Expects: questions (from questions.js)
  // Saves: localStorage.scores + localStorage.flags + localStorage.path

  const state = {
    scores: JSON.parse(localStorage.getItem("scores") || "{}"),
    answers: {},      // questionId -> mult
    flags: {          // computed continuously
      marxEligible: false,
      authMarx: null,           // true/false/null
      leninistEligible: false,
      mlStalinEligible: false,  // NEW: ML (Stalinism) splitter
      mlmQualified: false
    },
    history: [],      // list of indices shown
    pos: -1           // pointer into history
  };

  function num(x) {
    const n = parseFloat(x);
    return Number.isFinite(n) ? n : 0;
  }

  function setScore(key, delta) {
    state.scores[key] = num(state.scores[key]) + delta;
  }

  function applyEffect(q, mult) {
    if (!q.effect) return;
    for (const k of Object.keys(q.effect)) {
      setScore(k, mult * q.effect[k]);
    }
  }

  function isAgree(mult) { return mult >= 0.5; }
  function isDisagree(mult) { return mult <= -0.5; }
  function isUnsure(mult) { return mult === 0.0; }

  function recomputeFlags() {
    // --- Marx eligibility ---
    const marxQs = questions.filter(q => q.meta && q.meta.marxGate);
    const answeredMarx = marxQs.filter(q => state.answers[q.id] !== undefined);

    let marxAgree = 0;
    for (const q of marxQs) {
      const m = state.answers[q.id];
      if (m === undefined) continue;
      if (isAgree(m)) marxAgree += 1;
    }

    const marxComplete = (answeredMarx.length === marxQs.length);
    state.flags.marxEligible = marxComplete ? (marxAgree >= 6) : false;

    // --- Auth Marx tilt ---
    const tiltQ = questions.find(q => q.meta && q.meta.authTilt);
    if (tiltQ && state.answers[tiltQ.id] !== undefined) {
      const m = state.answers[tiltQ.id];
      if (isAgree(m)) state.flags.authMarx = true;
      else if (isDisagree(m)) state.flags.authMarx = false;
      else state.flags.authMarx = null;
    } else {
      state.flags.authMarx = null;
    }

    // --- Leninist eligibility ---
    // (Your current scheme: require 2/3 agrees on len_01..len_03)
    const requiredLenIds = ["len_01","len_02","len_03"];
    let reqAgree = 0, reqAnswered = 0;

    for (const id of requiredLenIds) {
      const q = questions.find(x => x.id === id);
      if (!q) continue;
      if (q.showIf && !q.showIf(state)) continue;
      const m = state.answers[id];
      if (m === undefined) continue;
      reqAnswered += 1;
      if (isAgree(m)) reqAgree += 1;
    }

    state.flags.leninistEligible =
      (reqAnswered === requiredLenIds.length) ? (reqAgree >= 2) : false;

    // --- ML (Stalinism) vs MLM SPLIT ---
    // You said: "disagreeing with the ONE at the end makes you ML instead of MLM"
    // So we look for the EXISTING question that you tag as meta.mlStalinSplit === true,
    // and if user DISAGREES (<= -0.5), we set mlStalinEligible true.
    const splitQ = questions.find(q => q.meta && q.meta.mlStalinSplit);
    if (state.flags.leninistEligible && splitQ && state.answers[splitQ.id] !== undefined) {
      state.flags.mlStalinEligible = isDisagree(state.answers[splitQ.id]);
    } else {
      state.flags.mlStalinEligible = false;
    }

    // --- MLM qualification (allow up to 1 unsure, no disagree) ---
    // IMPORTANT: if user is ML (Stalinism), we force MLM false (they are not on MLM path).
    if (state.flags.mlStalinEligible) {
      state.flags.mlmQualified = false;
      return;
    }

    const mlmQs = questions.filter(q => q.meta && q.meta.mlmGate);
    const relevantMlmQs = mlmQs.filter(q => !q.showIf || q.showIf(state));

    let mlmUnsure = 0, mlmAnswered = 0;
    for (const q of relevantMlmQs) {
      const m = state.answers[q.id];
      if (m === undefined) continue;
      mlmAnswered += 1;
      if (isUnsure(m)) mlmUnsure += 1;
    }

    if (relevantMlmQs.length > 0 && mlmAnswered === relevantMlmQs.length) {
      let anyDisagree = false;
      for (const q of relevantMlmQs) {
        const m = state.answers[q.id];
        if (m !== undefined && isDisagree(m)) { anyDisagree = true; break; }
      }
      state.flags.mlmQualified = (!anyDisagree && (mlmUnsure <= 1));
    } else {
      state.flags.mlmQualified = false;
    }
  }

  function showIfPasses(q) {
    return !q.showIf || q.showIf(state);
  }

  function findNextIndex(fromIndex) {
    for (let i = fromIndex + 1; i < questions.length; i++) {
      if (showIfPasses(questions[i])) return i;
    }
    return -1;
  }

  function persistState() {
    localStorage.setItem("scores", JSON.stringify(state.scores));
    localStorage.setItem("flags", JSON.stringify(state.flags));
    localStorage.setItem("path", JSON.stringify(state.history.map(i => questions[i].id)));
  }

  function currentIndex() {
    if (state.pos >= 0 && state.pos < state.history.length) return state.history[state.pos];
    return -1;
  }

  function init_question() {
    const idx = currentIndex();
    if (idx === -1) return;

    const q = questions[idx];
    document.getElementById("question-text").innerHTML = q.question;
    document.getElementById("question-number").innerHTML =
      "Question " + (state.pos + 1) + " of " + state.history.length;

    if (state.pos === 0) {
      document.getElementById("back_button").style.display = "none";
      document.getElementById("back_button_off").style.display = "block";
    } else {
      document.getElementById("back_button").style.display = "block";
      document.getElementById("back_button_off").style.display = "none";
    }
  }

  function start() {
    const first = findNextIndex(-1);
    if (first === -1) return results();

    state.history = [first];
    state.pos = 0;
    init_question();
  }

  function next_question(mult) {
    const idx = currentIndex();
    if (idx === -1) return;

    const q = questions[idx];

    // Apply scoring & record answer
    applyEffect(q, mult);
    state.answers[q.id] = mult;

    // Recompute flags and persist
    recomputeFlags();
    persistState();

    // Drop future history if user went back
    if (state.pos < state.history.length - 1) {
      state.history = state.history.slice(0, state.pos + 1);
    }

    // Find next eligible question
    const nextIdx = findNextIndex(idx);
    if (nextIdx === -1) return results();

    state.history.push(nextIdx);
    state.pos += 1;
    init_question();
  }

  function prev_question() {
    if (state.pos <= 0) return;
    state.pos -= 1;
    init_question();
  }

  function results() {
    recomputeFlags();
    persistState();
    location.href = "results.html";
  }

  start();
</script>
